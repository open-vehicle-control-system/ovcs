import{a as X}from"./chunk-FJZALV7F.js";import{a as G,b as R,c as T,d as M,e as F,f as Y,g as j,i as H,j as _,k as q,l as z,m as P}from"./chunk-5CG6MCMB.js";import"./chunk-GDYVCCNI.js";import{a as A}from"./chunk-IEVFQHBT.js";import"./chunk-DQY2Y6DO.js";import{a as K}from"./chunk-ZFJZTPK5.js";import{a as J}from"./chunk-AKQTM536.js";import"./chunk-WSSX4ADQ.js";import"./chunk-ZTFC2RI5.js";import{Z as B,h as b,j as r}from"./chunk-SOPNMMPO.js";import"./chunk-T2HSNUVK.js";import"./chunk-B7P5FXKN.js";import"./chunk-OIZLKBMD.js";import{a as D,b as k}from"./chunk-FC2K5MUR.js";var f=new Map,N=new Map,U=new Map,ne=b(()=>{N.clear(),U.clear(),f.clear()},"clear"),O=b((e,t)=>{let n=N.get(t)||[];return r.trace("In isDescendant",t," ",e," = ",n.includes(e)),n.includes(e)},"isDescendant"),te=b((e,t)=>{let n=N.get(t)||[];return r.info("Descendants of ",t," is ",n),r.info("Edge is ",e),e.v===t||e.w===t?!1:n?n.includes(e.v)||O(e.v,t)||O(e.w,t)||n.includes(e.w):(r.debug("Tilt, ",t,",not in descendants"),!1)},"edgeInCluster"),V=b((e,t,n,o)=>{r.warn("Copying children of ",e,"root",o,"data",t.node(e),o);let l=t.children(e)||[];e!==o&&l.push(e),r.warn("Copying (nodes) clusterId",e,"nodes",l),l.forEach(c=>{if(t.children(c).length>0)V(c,t,n,o);else{let s=t.node(c);r.info("cp ",c," to ",o," with parent ",e),n.setNode(c,s),o!==t.parent(c)&&(r.warn("Setting parent",c,t.parent(c)),n.setParent(c,t.parent(c))),e!==o&&c!==e?(r.debug("Setting parent",c,e),n.setParent(c,e)):(r.info("In copy ",e,"root",o,"data",t.node(e),o),r.debug("Not Setting parent for node=",c,"cluster!==rootId",e!==o,"node!==clusterId",c!==e));let g=t.edges(c);r.debug("Copying Edges",g),g.forEach(d=>{r.info("Edge",d);let p=t.edge(d.v,d.w,d.name);r.info("Edge data",p,o);try{te(d,o)?(r.info("Copying as ",d.v,d.w,p,d.name),n.setEdge(d.v,d.w,p,d.name),r.info("newGraph edges ",n.edges(),n.edge(n.edges()[0]))):r.info("Skipping copy of edge ",d.v,"-->",d.w," rootId: ",o," clusterId:",e)}catch(C){r.error(C)}})}r.debug("Removing node",c),t.removeNode(c)})},"copy"),W=b((e,t)=>{let n=t.children(e),o=[...n];for(let l of n)U.set(l,e),o=[...o,...W(l,t)];return o},"extractDescendants"),ie=b((e,t,n)=>{let o=e.edges().filter(d=>d.v===t||d.w===t),l=e.edges().filter(d=>d.v===n||d.w===n),c=o.map(d=>({v:d.v===t?n:d.v,w:d.w===t?t:d.w})),s=l.map(d=>({v:d.v,w:d.w}));return c.filter(d=>s.some(p=>d.v===p.v&&d.w===p.w))},"findCommonEdges"),S=b((e,t,n)=>{let o=t.children(e);if(r.trace("Searching children of id ",e,o),o.length<1)return e;let l;for(let c of o){let s=S(c,t,n),g=ie(t,n,s);if(s)if(g.length>0)l=s;else return s}return l},"findNonClusterChild"),Q=b(e=>!f.has(e)||!f.get(e).externalConnections?e:f.has(e)?f.get(e).id:e,"getAnchorId"),re=b((e,t)=>{if(!e||t>10){r.debug("Opting out, no graph ");return}else r.debug("Opting in, graph ");e.nodes().forEach(function(n){e.children(n).length>0&&(r.warn("Cluster identified",n," Replacement id in edges: ",S(n,e,n)),N.set(n,W(n,e)),f.set(n,{id:S(n,e,n),clusterData:e.node(n)}))}),e.nodes().forEach(function(n){let o=e.children(n),l=e.edges();o.length>0?(r.debug("Cluster identified",n,N),l.forEach(c=>{let s=O(c.v,n),g=O(c.w,n);s^g&&(r.warn("Edge: ",c," leaves cluster ",n),r.warn("Descendants of XXX ",n,": ",N.get(n)),f.get(n).externalConnections=!0)})):r.debug("Not a cluster ",n,N)});for(let n of f.keys()){let o=f.get(n).id,l=e.parent(o);l!==n&&f.has(l)&&!f.get(l).externalConnections&&(f.get(n).id=l)}e.edges().forEach(function(n){let o=e.edge(n);r.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(n)),r.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(e.edge(n)));let l=n.v,c=n.w;if(r.warn("Fix XXX",f,"ids:",n.v,n.w,"Translating: ",f.get(n.v)," --- ",f.get(n.w)),f.get(n.v)||f.get(n.w)){if(r.warn("Fixing and trying - removing XXX",n.v,n.w,n.name),l=Q(n.v),c=Q(n.w),e.removeEdge(n.v,n.w,n.name),l!==n.v){let s=e.parent(l);f.get(s).externalConnections=!0,o.fromCluster=n.v}if(c!==n.w){let s=e.parent(c);f.get(s).externalConnections=!0,o.toCluster=n.w}r.warn("Fix Replacing with XXX",l,c,n.name),e.setEdge(l,c,o,n.name)}}),r.warn("Adjusted Graph",X(e)),Z(e,0),r.trace(f)},"adjustClustersAndEdges"),Z=b((e,t)=>{var l,c;if(r.warn("extractor - ",t,X(e),e.children("D")),t>10){r.error("Bailing out");return}let n=e.nodes(),o=!1;for(let s of n){let g=e.children(s);o=o||g.length>0}if(!o){r.debug("Done, no node has children",e.nodes());return}r.debug("Nodes = ",n,t);for(let s of n)if(r.debug("Extracting node",s,f,f.has(s)&&!f.get(s).externalConnections,!e.parent(s),e.node(s),e.children("D")," Depth ",t),!f.has(s))r.debug("Not a cluster",s,t);else if(!f.get(s).externalConnections&&e.children(s)&&e.children(s).length>0){r.warn("Cluster without external connections, without a parent and with children",s,t);let d=e.graph().rankdir==="TB"?"LR":"TB";(c=(l=f.get(s))==null?void 0:l.clusterData)!=null&&c.dir&&(d=f.get(s).clusterData.dir,r.warn("Fixing dir",f.get(s).clusterData.dir,d));let p=new J({multigraph:!0,compound:!0}).setGraph({rankdir:d,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});r.warn("Old graph before copy",X(e)),V(s,e,p,s),e.setNode(s,{clusterNode:!0,id:s,clusterData:f.get(s).clusterData,label:f.get(s).label,graph:p}),r.warn("New graph after copy node: (",s,")",X(p)),r.debug("Old graph after copy",X(e))}else r.warn("Cluster ** ",s," **not meeting the criteria !externalConnections:",!f.get(s).externalConnections," no parent: ",!e.parent(s)," children ",e.children(s)&&e.children(s).length>0,e.children("D"),t),r.debug(f);n=e.nodes(),r.warn("New list of nodes",n);for(let s of n){let g=e.node(s);r.warn(" Now next level",s,g),g!=null&&g.clusterNode&&Z(g.graph,t+1)}},"extractor"),$=b((e,t)=>{if(t.length===0)return[];let n=Object.assign([],t);return t.forEach(o=>{let l=e.children(o),c=$(e,l);n=[...n,...c]}),n},"sorter"),se=b(e=>$(e,e.children()),"sortNodesByHierarchy"),L=b(async(e,t,n,o,l,c)=>{r.warn("Graph in recursive render:XAX",X(t),l);let s=t.graph().rankdir;r.trace("Dir in recursive render - dir:",s);let g=e.insert("g").attr("class","root");t.nodes()?r.info("Recursive render XXX",t.nodes()):r.info("No nodes found for",t),t.edges().length>0&&r.info("Recursive edges",t.edge(t.edges()[0]));let d=g.insert("g").attr("class","clusters"),p=g.insert("g").attr("class","edgePaths"),C=g.insert("g").attr("class","edgeLabels"),u=g.insert("g").attr("class","nodes");await Promise.all(t.nodes().map(async function(a){let i=t.node(a);if(l!==void 0){let h=JSON.parse(JSON.stringify(l.clusterData));r.trace(`Setting data for parent cluster XXX
 Node.id = `,a,`
 data=`,h.height,`
Parent cluster`,l.height),t.setNode(l.id,h),t.parent(a)||(r.trace("Setting parent",a,l.id),t.setParent(a,l.id,h))}if(r.info("(Insert) Node XXX"+a+": "+JSON.stringify(t.node(a))),i!=null&&i.clusterNode){r.info("Cluster identified XBX",a,i.width,t.node(a));let{ranksep:h,nodesep:m}=t.graph();i.graph.setGraph(k(D({},i.graph.graph()),{ranksep:h+25,nodesep:m}));let E=await L(u,i.graph,n,o,t.node(a),c),x=E.elem;H(i,x),i.diff=E.diff||0,r.info("New compound node after recursive render XAX",a,"width",i.width,"height",i.height),q(x,i)}else t.children(a).length>0?(r.trace("Cluster - the non recursive path XBX",a,i.id,i,i.width,"Graph:",t),r.trace(S(i.id,t)),f.set(i.id,{id:S(i.id,t),node:i})):(r.trace("Node - the non recursive path XAX",a,u,t.node(a),s),await _(u,t.node(a),{config:c,dir:s}))})),await b(async()=>{let a=t.edges().map(async function(i){let h=t.edge(i.v,i.w,i.name);r.info("Edge "+i.v+" -> "+i.w+": "+JSON.stringify(i)),r.info("Edge "+i.v+" -> "+i.w+": ",i," ",JSON.stringify(t.edge(i))),r.info("Fix",f,"ids:",i.v,i.w,"Translating: ",f.get(i.v),f.get(i.w)),await M(C,h)});await Promise.all(a)},"processEdges")(),r.info("Graph before layout:",JSON.stringify(X(t))),r.info("############################################# XXX"),r.info("###                Layout                 ### XXX"),r.info("############################################# XXX"),K(t),r.info("Graph after layout:",JSON.stringify(X(t)));let y=0,{subGraphTitleTotalMargin:v}=A(c);return await Promise.all(se(t).map(async function(a){var h;let i=t.node(a);if(r.info("Position XBX => "+a+": ("+i.x,","+i.y,") width: ",i.width," height: ",i.height),i!=null&&i.clusterNode)i.y+=v,r.info("A tainted cluster node XBX1",a,i.id,i.width,i.height,i.x,i.y,t.parent(a)),f.get(i.id).node=i,P(i);else if(t.children(a).length>0){r.info("A pure cluster node XBX1",a,i.id,i.x,i.y,i.width,i.height,t.parent(a)),i.height+=v,t.node(i.parentId);let m=(i==null?void 0:i.padding)/2||0,E=((h=i==null?void 0:i.labelBBox)==null?void 0:h.height)||0,x=E-m||0;r.debug("OffsetY",x,"labelHeight",E,"halfPadding",m),await G(d,i),f.get(i.id).node=i}else{let m=t.node(i.parentId);i.y+=v/2,r.info("A regular node XBX1 - using the padding",i.id,"parent",i.parentId,i.width,i.height,i.x,i.y,"offsetY",i.offsetY,"parent",m,m==null?void 0:m.offsetY,i),P(i)}})),t.edges().forEach(function(a){let i=t.edge(a);r.info("Edge "+a.v+" -> "+a.w+": "+JSON.stringify(i),i),i.points.forEach(x=>x.y+=v/2);let h=t.node(a.v);var m=t.node(a.w);let E=Y(p,i,f,n,h,m,o);F(i,E)}),t.nodes().forEach(function(a){let i=t.node(a);r.info(a,i.type,i.diff),i.isGroup&&(y=i.diff)}),r.warn("Returning from recursive render XAX",g,y),{elem:g,diff:y}},"recursiveRender"),ue=b(async(e,t)=>{var c,s,g,d,p,C;let n=new J({multigraph:!0,compound:!0}).setGraph({rankdir:e.direction,nodesep:((c=e.config)==null?void 0:c.nodeSpacing)||((g=(s=e.config)==null?void 0:s.flowchart)==null?void 0:g.nodeSpacing)||e.nodeSpacing,ranksep:((d=e.config)==null?void 0:d.rankSpacing)||((C=(p=e.config)==null?void 0:p.flowchart)==null?void 0:C.rankSpacing)||e.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),o=t.select("g");j(o,e.markers,e.type,e.diagramId),z(),T(),R(),ne(),e.nodes.forEach(u=>{n.setNode(u.id,D({},u)),u.parentId&&n.setParent(u.id,u.parentId)}),r.debug("Edges:",e.edges),e.edges.forEach(u=>{if(u.start===u.end){let w=u.start,y=w+"---"+w+"---1",v=w+"---"+w+"---2",a=n.node(w);n.setNode(y,{domId:y,id:y,parentId:a.parentId,labelStyle:"",label:"",padding:0,shape:"labelRect",style:"",width:10,height:10}),n.setParent(y,a.parentId),n.setNode(v,{domId:v,id:v,parentId:a.parentId,labelStyle:"",padding:0,shape:"labelRect",label:"",style:"",width:10,height:10}),n.setParent(v,a.parentId);let i=structuredClone(u),h=structuredClone(u),m=structuredClone(u);i.label="",i.arrowTypeEnd="none",i.id=w+"-cyclic-special-1",h.arrowTypeEnd="none",h.id=w+"-cyclic-special-mid",m.label="",a.isGroup&&(i.fromCluster=w,m.toCluster=w),m.id=w+"-cyclic-special-2",n.setEdge(w,y,i,w+"-cyclic-special-0"),n.setEdge(y,v,h,w+"-cyclic-special-1"),n.setEdge(v,w,m,w+"-cyc<lic-special-2")}else n.setEdge(u.start,u.end,D({},u),u.id)}),r.warn("Graph at first:",JSON.stringify(X(n))),re(n),r.warn("Graph after XAX:",JSON.stringify(X(n)));let l=B();await L(o,n,e.type,e.diagramId,void 0,l)},"render");export{ue as render};
